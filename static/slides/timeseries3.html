<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>IM532 3.0 Applied Time Series Forecasting</title>
    <meta charset="utf-8" />
    <meta name="author" content="Thiyanga Talagala" />
    <meta name="date" content="2020-04-25" />
    <link href="libs/remark-css/default.css" rel="stylesheet" />
    <link href="libs/remark-css/default-fonts.css" rel="stylesheet" />
    <link href="libs/remark-css/duke-blue.css" rel="stylesheet" />
    <link href="libs/remark-css/hygge-duke.css" rel="stylesheet" />
    <link rel="stylesheet" href="libs/cc-fonts.css" type="text/css" />
    <link rel="stylesheet" href="libs/figure-captions.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# IM532 3.0 Applied Time Series Forecasting
## MSc in Industrial Mathematics
### Thiyanga Talagala
### 25 April 2020

---



# Non-Stationary Time Series

**1. Deterministic trend**

`$$Y_t  = f(t) + \epsilon_t$$`


where `\(\epsilon_t \sim iid(0, \sigma^2)\)`, `\(t = 1, 2, ...T\)`

Mean of the process is time dependent, but the variance of the process is constant.

**2. Random walk**

`$$Y_t = Y_{t-1} + \epsilon_t$$`

**3. Random walk with drift**

`$$Y_t = \alpha+  Y_{t-1} + \epsilon_t$$`

**4. Random walk with drift and deterministic trend**

---
# Common trend removal (de-trending) procedures

1. Deterministic trend: Time-trend regression

      The trend can be removed by fitting a deterministic polynomial time trend. The residual series after removing the trend will give us the de-trended series.

1. Stochastic trend: Differencing
 
      The process is also known as a **Difference-stationary process**.



---

# Trend stationary time series

---

# Difference stationary time series

--
      
# Notation: I(d)

Integrated to order `\(d\)`, `\(I(d)\)`:

series can be made stationary by differencing `\(d\)` times.



---

# Difference stationary process: Random walk model (RW)

**Question: ** Show that random walk process is an `\(I(1)\)` process.

---

# Deterministic trend + Stochastic trend: Random walk with drift (RWD)


---

# Summary: RW vs RWD

---

# Variance stabilization

Eg:

- Square root: `\(W_t = \sqrt{Y_t}\)`

- Logarithm: `\(W_t = log({Y_t})\)`

     - This very useful.
     
     - Interpretable: Changes in a log value are **relative (percent) changes on the original sclae**.
     


---

### Monthly Airline Passenger Numbers 1949-1960

.pull-left[

**Without transformations**

![](timeseries3_files/figure-html/unnamed-chunk-1-1.png)&lt;!-- --&gt;

]

.pull-right[

**Square root transformation**

![](timeseries3_files/figure-html/unnamed-chunk-2-1.png)&lt;!-- --&gt;
]
---


### Australian monthly electricity production: Jan 1956 – Aug 1995

.pull-left[

**Without transformations**

![](timeseries3_files/figure-html/unnamed-chunk-3-1.png)&lt;!-- --&gt;

]

.pull-right[

**Logarithm transformation**

![](timeseries3_files/figure-html/unnamed-chunk-4-1.png)&lt;!-- --&gt;
]

---

# Box-Cox transformation

$$
  f(x)=\begin{cases}
    1, &amp; \text{if `\(x&lt;0\)`} \newline
    0, &amp; \text{otherwise}.
  \end{cases}
$$


Different values of `\(\lambda\)` gives you different transformations.

- `\(\lambda=1\)`: No **substantive** transformation

- `\(\lambda = \frac{1}{2}\)`: Square root plus linear transformation

- `\(\lambda=0\)`: Natural logarithm

- `\(\lambda = -1\)`: Inverse plus 1

Balance the seasonal fluctuations and random variation across the series.

---

# Box-Cox transformation: R codes

**BoxCox.lambda: Automatic selection of Box Cox transformation parameter**


```r
forecast::BoxCox.lambda(AirPassengers)
```

```
[1] -0.2947156
```

Some times this value is not sensible.

**BoxCox: Transformation of the input variable using a Box-Cox transformation**

```r
lambda &lt;- forecast::BoxCox.lambda(AirPassengers)
w &lt;- BoxCox(AirPassengers, lambda)
```

You can pass a user-defined value for `lambda`.

**InvBoxCox: Reverse transformation**

```r
InvBox(w)
```

---

## Box-Cox transformation on `AirPassengers`

.pull-left[

**Without transformations**

```r
autoplot(AirPassengers)+ylab("Monthly Airline Passenger Numbers 1949-1960")
```

![](timeseries3_files/figure-html/unnamed-chunk-6-1.png)&lt;!-- --&gt;

]

.pull-right[

**Box-Cox transformation**

```r
lambda &lt;- forecast::BoxCox.lambda(AirPassengers)
*autoplot(BoxCox(AirPassengers, lambda))+
ylab("Monthly Airline Passenger Numbers 1949-1960")
```



![](timeseries3_files/figure-html/unnamed-chunk-7-1.png)&lt;!-- --&gt;
]

What differences do you notice in the scale?
---

## Note: Box-Cox Transformation

- If `\(\lambda = 0\)`? 

    - Behaves like log transformation. 
    
    - Force forecasts to be positive.
--

- If `\(\lambda =1\)`? No transformation is needed.
--

- If some `\(Y_t = 0\)`?, then must have `\(\lambda &gt; 0\)`.
--
- If some `\(Y_t &lt; 0\)`? Use power transformation or adjust the time series **by adding a constant to all values.**

--

- Choose a simple value of `\(\lambda\)`. It makes explanations easier.

--

- Transformation oftem makes little difference to forecasts but has large effects on PI.

---
# Application

`snaive` + applying BoxCox transformation

.pull-left[


```r
fit &lt;- snaive(AirPassengers, lambda = 0)
autoplot(fit)
```

![](timeseries3_files/figure-html/unnamed-chunk-8-1.png)&lt;!-- --&gt;
]

.pull-right[

## Steps: 

✅ apply Box-Cox transformation.

✅ fit a model.

✅ reverse transformation.

]

&lt;!-- R will do the Box-Cox transformation, Fit model, back transformation--&gt;

---

## What differences do you notice?

.pull-left[

![](timeseries3_files/figure-html/unnamed-chunk-9-1.png)&lt;!-- --&gt;
]

.pull-right[

![](timeseries3_files/figure-html/unnamed-chunk-10-1.png)&lt;!-- --&gt;


]

&lt;!--Monotonically increasing variance vs Non-monotonically increasing variance. Any monotonic transformation wouldn't work here. When you apply boxcox transformation it will transform one part and do the opposite for the other part. There are different ways to handle this. What transformation would work for cangas data set. Video:sd1-4 (48) --&gt;

---
# Detecting non stationarity by visual inspections of plots and ACF


---

# Testing for nonstationarity for the presence of unit roots

---

# Dickey and Fuller (DF) tests


---

# Augmented DF tests


---

# Phillips and Perron (PP) nonparametric tests
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="libs/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
